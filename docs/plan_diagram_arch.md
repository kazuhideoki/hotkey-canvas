# Diagram Mode アーキテクチャ方針（概要）

## 1. 目的

- 初回議論メモの内容を、実装着手前の意思決定として固定する。
- Diagram mode の提供価値に直結する方針を先に確定し、詳細設計は各実装フェーズで行う。
- 最終的に Tree と Diagram が 1 キャンバス内で混在可能な設計へ段階的に移行する。

## 2. 提供価値（最優先）

- 最優先価値は **キーボード編集速度** とする。
- ユーザーがモード切替を意識しなくても、フォーカス位置に応じて意図した編集ができることを重視する。
- 視覚調整の自由度拡張は後続で扱い、初期は操作の一貫性と予測可能性を優先する。

## 3. 先行確定する意思決定

### 3.1 モード単位

- キャンバス全体モードではなく、**エリア単位モード** を採用する。
- 1 キャンバス内で Tree エリアと Diagram エリアを共存させる。

### 3.2 データ構造と意味論

- `CanvasGraph` / `CanvasNode` / `CanvasEdge` は共通基盤として維持する。
- モード差分はモデル分離ではなく、エリアポリシーで扱う。
- すなわち「構造は共通、意味論はエリアごとに分離」を基本方針とする。

### 3.3 入口とディスパッチ

- `CanvasEditingInputPort.apply(commands:)` の単一入口は維持する。
- 実行時にフォーカスノード所属エリアを解決し、エリアモードに応じてコマンドをディスパッチする。
- 非対応コマンドは暗黙 no-op ではなく、明示エラーとして返す。

### 3.4 エリア所属

- 初期方針は **手動中心** とする。
- エリア所属は明示操作を基本とし、自動変更による誤編集を避ける。

### 3.5 エリア跨ぎエッジ

- 初期リリースでは **全面禁止** とする。
- 将来拡張の余地は残し、禁止方針を解除できる設計フックを保持する。

### 3.6 モード変換

- モード変換は暗黙切替で行わず、明示コマンドとして扱う。
- 変換失敗時は理由を返し、失敗を握り潰さない。

## 4. 設計方針（概要）

### 4.1 Domain 型追加の方向性

- `CanvasAreaID`
- `CanvasEditingMode`（`tree` / `diagram`）
- `CanvasArea`（`id`, `nodeIDs`, `editingMode`）

注記:

- 具体的な配置先（`Sources/Domain/Model` など）と命名確定は各実装フェーズで決定する。

### 4.2 Application 調停の方向性

- `apply` 内の command dispatch に、エリア解決ステップを導入する。
- `TreeAreaPolicyService` / `DiagramAreaPolicyService`（仮）を分離し、`AreaPolicyDispatcher`（仮）で選択する。
- 現在の Tree 前提フラグ中心のステージ実行は、モード別要件を表現できる形へ再整理する。

### 4.3 エラー契約

- 追加予定のエラーは、少なくとも以下の失敗理由を識別できることを要件とする。
- 対象ノードがエリア未所属
- 対象エリアのモードでコマンド非対応
- 跨ぎエッジ禁止違反
- 変換前提条件未達

## 5. 対応フェーズ

### Phase 1: 基盤導入

目的:

- エリア単位モードの最小骨格を導入し、責務境界を固定する。

主要対応:

- `CanvasArea` / `CanvasEditingMode` の最小型導入
- エリア解決ルール（フォーカス基準）の明文化
- モード別ディスパッチ境界の導入
- 非対応コマンドを返すエラー契約の定義

完了条件:

- 混在前提の責務分担がコードとドキュメントで矛盾なく説明できる。

### Phase 2: 混在編集成立

目的:

- Tree/Diagram 混在キャンバスで、主要編集操作を安全に成立させる。

主要対応:

- エリアモード別ポリシー実装
- コマンド適用時の対象エリア解決を一貫運用
- 跨ぎエッジ全面禁止を強制
- Undo/Redo でエリア関連操作の整合性を維持

Phase2 実装メモ（確定事項）:

- Diagram mode で `addNode` / `deleteFocusedNode` / `createArea` / `assignNodesToArea` / `moveNode` を許可する。
- Diagram mode では `addSiblingNode` / `toggleFoldFocusedSubtree` は非対応のままとする。
- Diagram mode での `addChildNode` は互換ショートカット入口として `addNode` に正規化して扱う。
- `addNode` はフォーカス未解決かつ複数エリア存在時に暗黙選択せず失敗させる。
- `createArea` / `assignNodesToArea` 実行後に跨ぎエッジが生じる場合は操作全体を失敗とする。

完了条件:

- 混在キャンバスで、意図しないモード誤適用が再現しない。

### Phase 3: 変換と拡張準備

目的:

- 明示変換コマンドと将来拡張ポイントを整備する。
- Diagram 作成導線を UI から到達可能にする。

主要対応:

- `convertAreaMode` 相当コマンドの導入
- 変換成功/失敗条件と失敗理由返却の契約化
- `Shift + Enter` による新規ノード作成時、`Tree` / `Diagram` を選択するダイアログ導線を導入する。
  - `Diagram` 選択時は、暗黙フォールバックを行わず、明示コマンド（`createArea` / `assignNodesToArea`）で所属とモードを確定させる。
- 将来の跨ぎエッジ許可に向けた拡張ポイント整理

完了条件:

- 変換操作が Undo/Redo と矛盾せず、失敗理由が説明可能である。
- ユーザーがアプリ操作のみで Diagram エリアを作成し、Diagram 内で `addNode` を実行できる。

## 6. テスト観点（先行固定）

- 混在キャンバスで同一コマンド列に対する決定的結果
- モード境界での許可/禁止コマンド判定
- 非対応コマンドの明示エラー契約
- 跨ぎエッジ禁止ルールの保証
- 変換コマンドの成功/失敗条件、および Undo/Redo 整合性

## 7. スコープ外（本ドキュメント時点）

- Diagram 固有レイアウトアルゴリズムの詳細
- UI 表示仕様の詳細（見た目、アニメーション、細かな操作フィードバック）
  - ただし Phase 3 の `Shift + Enter` モード選択ダイアログ導線は対象内とする。
- ショートカット細目の最終確定

## 8. リスクと対処方針

- リスク: エリア所属更新契約が曖昧だと、混在編集で整合性が崩れる。
- 対処: Phase 1 で所属更新イベントと責務境界を先に固定する。

- リスク: Tree 前提の既存パイプラインが Diagram 要件を阻害する。
- 対処: Phase 1-2 でステージ条件をモード非依存な形へ再定義する。

- リスク: 変換仕様を先送りしすぎると、後段で破壊的変更が必要になる。
- 対処: Phase 3 で変換失敗理由を含む契約を先に固定する。

## 9. ドキュメント運用

- 本方針は概要設計の単一参照とし、実装詳細は各フェーズ設計ドキュメントへ委譲する。
- Domain/Application の実装変更が発生した場合は、`docs/domain.md` と整合させる。
- 重要判断を変更する場合は、本書を先に更新してから実装を進める。
